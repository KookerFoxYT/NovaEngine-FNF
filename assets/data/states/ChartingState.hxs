import flixel.addons.display.FlxGridOverlay;
import flixel.util.FlxStringUtil;
import flixel.FlxObject;
import core.utilities.MathUtil;

// TODO: ADDING + DELETING NOTES, AND MODIFIED SONG & SECTION DATA

var SONG:SongData;

var bg:FlxSprite;

var gridBG:FlxSprite;
var gridBGTop:FlxSprite;
var gridBGBottom:FlxSprite;
var gridSeperator:FlxSprite;

var camFollow:FlxObject;
var dummyNote:FlxSprite;
var strumLine:FlxSprite;

var ROWS:Int = 16;
var COLUMNS:Int = 8;
var GRID_SIZE:Int = 40;

var selectedSection:Int = 0;

var vocals:FlxSound;
var musicList:Array<FlxSound> = [];

var bpmTxt:FlxText;

var iconP2:HealthIcon;
var iconP1:HealthIcon;

var prevRenderedNotes:FlxGroup;
var prevRenderedSustains:FlxGroup;

var curRenderedNotes:FlxGroup;
var curRenderedSustains:FlxGroup;

var nextRenderedNotes:FlxGroup;
var nextRenderedSustains:FlxGroup;

var strumNotes:FlxGroup;

var curNoteType:Int = 0;
var curSelectedNote:Array<Dynamic>;

var noteTypeList:Array<String> = [
    "Default",
    "Alt Animation"
];

function yToTime(y:Float) {
	return FlxMath.remapToRange(y, gridBG.y, gridBG.y + gridBG.height, 0, 16 * Conductor.stepCrochet);
}

function timeToY(time:Float) {
	return FlxMath.remapToRange(time, 0, 16 * Conductor.stepCrochet, gridBG.y, gridBG.y + gridBG.height);
}

function sectionStartTime(?section) {
	if(section == null)
		section = selectedSection;
	
	var coolPos:Float = 0;
	var goodBPM:Float = Conductor.bpm;
	
	for(i in 0...section) {
        if(SONG.notes[i].changeBPM)
            goodBPM = SONG.notes[i].bpm;
		
		coolPos += 4 * (1000 * (60 / goodBPM));
    }
	
	return coolPos;
}

function onCreate() {
    SONG = PlayState.SONG;

    FlxG.sound.playMusic(Paths.songInst(SONG.song, PlayState.storyDifficulty), 1);
    FlxG.sound.music.pause();
    FlxG.sound.music.time = 0;

    FlxG.sound.list.add(vocals = new FlxSound().loadEmbedded(Paths.songVoices(SONG.song, PlayState.storyDifficulty)));

    Conductor.position = 0;

    add(bg = new FlxSprite().loadGraphic(Paths.image("menus/base/menuBGDesat")));
    bg.screenCenter();
    bg.scrollFactor.set();
    bg.alpha = 0.2;

    add(gridBG = FlxGridOverlay.create(GRID_SIZE, GRID_SIZE, GRID_SIZE * COLUMNS, GRID_SIZE * ROWS));
    gridBG.screenCenter(FlxAxes.X);

    add(gridBGTop = FlxGridOverlay.create(GRID_SIZE, GRID_SIZE, GRID_SIZE * COLUMNS, GRID_SIZE * ROWS));
    gridBGTop.screenCenter(FlxAxes.X);
    gridBGTop.y -= gridBG.height;

    add(gridBGBottom = FlxGridOverlay.create(GRID_SIZE, GRID_SIZE, GRID_SIZE * COLUMNS, GRID_SIZE * ROWS));
    gridBGBottom.screenCenter(FlxAxes.X);
    gridBGBottom.y += gridBG.height;

    add(gridSeperator = new FlxSprite(gridBG.x + (gridBG.width * 0.5), gridBGTop.y).makeGraphic(2, gridBGTop.height + gridBG.height + gridBGBottom.height, 0xFF000000));
    gridSeperator.alpha = 0.4;

    for(dupeGrid in [gridBGTop, gridBGBottom])
        dupeGrid.alpha = 0.4;

    add(dummyNote = new FlxSprite(gridBG.x, gridBG.y).makeGraphic(GRID_SIZE, GRID_SIZE, 0xFFFFFFFF));
    add(strumLine = new FlxSprite(gridBG.x, gridBG.y).makeGraphic(gridBG.width, 5, 0xFFFFFFFF));

    add(prevRenderedNotes = new FlxGroup());
    add(prevRenderedSustains = new FlxGroup());

    add(curRenderedSustains = new FlxGroup());

    add(nextRenderedNotes = new FlxGroup());
    add(nextRenderedSustains = new FlxGroup());

    add(strumNotes = new FlxGroup());
    add(curRenderedNotes = new FlxGroup());

    add(iconP2 = new HealthIcon(0, 20, SONG.player2));
    add(iconP1 = new HealthIcon(0, 20, SONG.player1));

    for(icon in [iconP2, iconP1]) {
        icon.scrollFactor.set();
        icon.scale.set(icon.initialScale * 0.5, icon.initialScale * 0.5);
        icon.updateHitbox();
        icon.screenCenter(FlxAxes.X);
    }

    var iconSpacing:Float = gridBG.width * 0.5;
    iconP2.x -= iconSpacing - iconP2.width;
    iconP1.x += iconSpacing - iconP1.width;

    add(bpmTxt = new FlxText(gridBG.x + (gridBG.width + 10), 10, 0, "", 16));
    bpmTxt.scrollFactor.set();

    add(camFollow = new FlxObject(FlxG.width * 0.5, 250, 1, 1));
    FlxG.camera.follow(camFollow, null, 1);

    musicList = [FlxG.sound.music, vocals];
    musicList[0].onComplete = () -> {
        FlxG.sound.music.pause();
        Conductor.position = 0;
        if(vocals != null) {
            vocals.pause();
            vocals.time = 0;
        }
        selectedSection = 0;
        changeSection();
        updateGrid();
        Conductor.update();
    }

    for(i in 0...(SONG.keyCount * 2)) {
        var receptor = new Receptor(gridBG.x + (GRID_SIZE * i), gridBG.y, "default", SONG.keyCount, i % SONG.keyCount);
        receptor.setGraphicSize(GRID_SIZE, GRID_SIZE);
        receptor.updateHitbox();
        receptor.initialScale = receptor.scale.x;

        var strumLine = new StrumLine();
        strumLine.autoplay = true;
        receptor.parent = strumLine;

        strumNotes.add(receptor);
    }

    updateGrid();
}

function changeSection(?change:Int) {
    if(change == null) change = 0;
    selectedSection += change;
    if(selectedSection < 0) selectedSection = 0;

    if(SONG.notes[selectedSection] == null) {
        SONG.notes.push({
            sectionNotes: [],
            lengthInSteps: SONG.notes[SONG.notes.length - 1].lengthInSteps,
            sectionBeats: SONG.notes[SONG.notes.length - 1].sectionBeats,
            mustHitSection: SONG.notes[SONG.notes.length - 1].mustHitSection,
            bpm: 0,
            changeBPM: false,
            altAnim: false
        });
    }

    updateGrid();
}

function initNote(dataShit:Array<Dynamic>, section:Int) {
    var strumTime:Float = dataShit[0];
    var noteData:Int = dataShit[1];
    var sustainLength:Float = dataShit[2];
    var noteType:Dynamic = dataShit[3];

    var note = new Note(-9999, -9999, PlayState.changeableSkin, SONG.keyCount, noteData % SONG.keyCount);
    note.strumTime = strumTime - SettingsAPI.noteOffset;
    note.curSection = section;
    note.sustainLength = sustainLength;
    note.rawNoteData = noteData;
    note.noteType = noteType;
    note.setGraphicSize(GRID_SIZE, GRID_SIZE);
    note.updateHitbox();
    note.x = gridBG.x + Math.floor(noteData * GRID_SIZE);
    note.y = timeToY((strumTime - sectionStartTime()));
    note.alpha = 0.4;

    if(SONG.notes[section].mustHitSection) {
        note.rawNoteData = Std.int((noteData + SONG.keyCount) % (SONG.keyCount * 2));
        note.x = gridBG.x + Math.floor((noteData + SONG.keyCount) % (SONG.keyCount * 2) * GRID_SIZE);
    }

    return note;
}

function updateGrid() {
    for(list in [prevRenderedNotes, curRenderedNotes, nextRenderedNotes, prevRenderedSustains, curRenderedSustains, nextRenderedSustains]) {
        for(item in list) {
            item.kill();
            item.destroy();
        }
        list.clear();
    }

    if (SONG.notes[selectedSection].changeBPM && SONG.notes[selectedSection].bpm > 0)
        Conductor.bpm = SONG.notes[selectedSection].bpm;
    else {
        // get last bpm
        var daBPM:Float = SONG.bpm;
        for (i in 0...selectedSection) {
            if (SONG.notes[i].changeBPM)
                daBPM = SONG.notes[i].bpm;
        }
        Conductor.bpm = daBPM;
    }

    var groups:Array<Array<FlxGroup>> = [
        [prevRenderedNotes, prevRenderedSustains],
        [curRenderedNotes, curRenderedSustains],
        [nextRenderedNotes, nextRenderedSustains]
    ];
    var sectionsToRender = [
        selectedSection - 1,
        selectedSection,
        selectedSection + 1
    ];
    var penis:Int = 0;
    for(section in sectionsToRender) {
        if(section < 0 || section >= SONG.notes.length) {
            penis++;
            continue;
        }

        for(note in SONG.notes[section].sectionNotes) {
            var sustainLength:Float = note[2];
    
            var note = initNote(note, section);
            groups[penis][0].add(note);

            if (sustainLength > 0) {
                var sustainVis:FlxSprite = new FlxSprite(note.x + (GRID_SIZE / 2), note.y + GRID_SIZE).makeGraphic(8, Math.floor(FlxMath.remapToRange(sustainLength, 0, Conductor.stepCrochet * 16, 0, gridBG.height)));
                sustainVis.x -= sustainVis.width * 0.5;
                groups[penis][1].add(sustainVis);
            }
        }

        penis++;
    }
}

function addNote() {
    var strumTime:Float = yToTime(dummyNote.y) + sectionStartTime();
    var noteData:Int = Math.floor((FlxG.mouse.x - gridBG.x) / GRID_SIZE);

    if(SONG.notes[selectedSection].mustHitSection)
        noteData = Math.floor((noteData + SONG.keyCount) % (SONG.keyCount * 2));

    SONG.notes[selectedSection].sectionNotes.push([strumTime, noteData, 0, noteTypeList[curNoteType]]);
    curSelectedNote = SONG.notes[selectedSection].sectionNotes[SONG.notes[selectedSection].sectionNotes.length - 1];

    curRenderedNotes.add(initNote(curSelectedNote, selectedSection));
}

function selectNote(note:Note) {
    var swagNum:Int = 0;

    for (i in SONG.notes[selectedSection].sectionNotes) {
        if (i[0] == note.strumTime && i[1] == note.rawNoteData) {
            curSelectedNote = SONG.notes[selectedSection].sectionNotes[swagNum];
            break;
        }
        swagNum++;
    }
}

function deleteNote(note:Note) {
    for (i in SONG.notes[selectedSection].sectionNotes) {
        if (i[0] == note.strumTime && i[1] == note.rawNoteData) {
            if(i == curSelectedNote) curSelectedNote = null;
            SONG.notes[selectedSection].sectionNotes.remove(i);
        }
    }
    updateGrid();
}

function changeNoteSustain(value:Float) {
    if (curSelectedNote != null) {
        if (curSelectedNote[2] != null) {
            curSelectedNote[2] += value;
            curSelectedNote[2] = Math.max(curSelectedNote[2], 0);
        }
    }
    updateGrid();
}

var colorSine:Float = 0;

function onUpdate(elapsed:Float) {
    vocals.volume = (SONG.needsVoices) ? 1 : 0;

    var iconLerp:Float = 0.15;

    var P2Scale:Float = (SONG.notes[selectedSection].mustHitSection) ? iconP2.initialScale * 0.4 : iconP2.initialScale * 0.5;
    var P2Alpha:Float = (SONG.notes[selectedSection].mustHitSection) ? 0.6 : 1;
    iconP2.scale.set(MathUtil.lerp(iconP2.scale.x, P2Scale, iconLerp), MathUtil.lerp(iconP2.scale.y, P2Scale, iconLerp));
    iconP2.alpha = MathUtil.lerp(iconP2.alpha, P2Alpha, iconLerp);

    var P1Scale:Float = (SONG.notes[selectedSection].mustHitSection) ? iconP1.initialScale * 0.5 : iconP1.initialScale * 0.4;
    var P1Alpha:Float = (SONG.notes[selectedSection].mustHitSection) ? 1 : 0.6;
    iconP1.scale.set(MathUtil.lerp(iconP1.scale.x, P1Scale, iconLerp), MathUtil.lerp(iconP1.scale.y, P1Scale, iconLerp));
    iconP1.alpha = MathUtil.lerp(iconP1.alpha, P1Alpha, iconLerp);

    if(FlxG.keys.justPressed.SPACE) {
        if(musicList[0].playing) {
            for(music in musicList) {
                music.pause();
                music.time = Conductor.position;
            }
        } else {
            for(music in musicList) {
                music.time = Conductor.position;
                music.play();
            }
        }
    } else if(controls.ACCEPT) {
        persistentUpdate = false;
        persistentDraw = true;
        PlayState.SONG = SONG;

        for(obj in [gridBG, gridBGTop, gridBGBottom, curRenderedNotes, curRenderedSustains, dummyNote, strumLine]) {
            obj.kill();
            obj.destroy();
            remove(obj, true);
        }

        for(music in musicList)
            music.stop();

        FlxG.switchState(new PlayState());
        return;
    }

    if(FlxG.mouse.wheel != 0) {
        Conductor.position -= (FlxG.mouse.wheel * Conductor.stepCrochet * 0.4);
        if(Conductor.position < 0)
            Conductor.position = 0;

        if(Conductor.position >= FlxG.sound.music.length) {
            Conductor.position = 0;
            selectedSection = 0;
            changeSection();
            Conductor.update();
        }

        for(music in musicList) {
            music.pause();
            music.time = Conductor.position;
        }
    }

    if(musicList[0].playing)
        Conductor.position += elapsed * 1000;

    if(Conductor.position < sectionStartTime()) {
        changeSection(-1);
        for(music in musicList) {
            music.pause();
            music.time = Conductor.position;
        }
    }

    if(Conductor.position > sectionStartTime() + (4 * (1000 * (60 / Conductor.bpm)))) {
        changeSection(1);
        Conductor.position = sectionStartTime();
        var playing = musicList[0].playing;
        for(music in musicList) {
            music.pause();
            music.time = Conductor.position;
            if(playing)
                music.play();
        }
    }

    var left:Bool = (FlxG.keys.justPressed.A || FlxG.keys.justPressed.LEFT);
    var right:Bool = (FlxG.keys.justPressed.D || FlxG.keys.justPressed.RIGHT);

    if(left || right) {
        changeSection((right ? 1 : 0) + (left ? -1 : 0));
        Conductor.position = sectionStartTime();
        for(music in musicList) {
            music.pause();
            music.time = Conductor.position;
        }
    }

    if(musicList[0].playing && !Conductor.isAudioSynced(musicList[0])) {
        for(music in musicList) {
            music.pause();
            music.time = Conductor.position;
            music.play();
        }
    }

    Conductor.update();

    var mousePos = [
        Math.floor(FlxG.mouse.x / GRID_SIZE) * GRID_SIZE,
        (FlxG.keys.pressed.SHIFT) ? FlxG.mouse.y : Math.floor(FlxG.mouse.y / GRID_SIZE) * GRID_SIZE
    ];
    var dummyVisible:Bool = (
        mousePos[0] >= gridBG.x &&
        mousePos[0] <= (gridBG.x + gridBG.width) - GRID_SIZE &&
        mousePos[1] >= gridBG.y &&
        mousePos[1] <= (gridBG.y + gridBG.height) - GRID_SIZE
    );

    if(dummyVisible) {
        dummyNote.setPosition(
            mousePos[0],
            mousePos[1]
        );
    }

    if(FlxG.mouse.justPressed) {
        if (FlxG.mouse.overlaps(curRenderedNotes)) {
            curRenderedNotes.forEach((note:Note) -> {
                if(!FlxG.mouse.overlaps(note)) return;

                if(FlxG.keys.pressed.CONTROL)
                    selectNote(note);
                else
                    deleteNote(note);
            });
        } else if(dummyVisible)
            addNote();
    }

    if(curSelectedNote != null) {
        if (FlxG.keys.justPressed.Q)
            changeNoteSustain(-Conductor.stepCrochet);

        if (FlxG.keys.justPressed.E)
            changeNoteSustain(Conductor.stepCrochet);
    }

    curRenderedNotes.forEach((note:Note) -> {
        note.color = 0xFFFFFFFF;

        if (curSelectedNote != null && curSelectedNote[0] == note.strumTime && curSelectedNote[1] == note.rawNoteData) {
            colorSine += FlxG.elapsed;
            var colorVal:Float = 0.7 + Math.sin(Math.PI * colorSine) * 0.3;
            note.color = FlxColor.fromRGBFloat(colorVal, colorVal, colorVal, 0.999); //Alpha can't be 100% or the color won't be updated for some reason, good job flixel devs
        }

        if(yToTime(note.y) + (Conductor.stepCrochet / 4) <= Conductor.position - sectionStartTime()) {
            if(musicList[0].playing && note.noteData >= 0 && note.alpha == 1) {
                FlxG.sound.play(Paths.sound("game/hitsound"));
                var receptor:Receptor = strumNotes.members[note.rawNoteData];
                receptor.playAnim("confirm", true);
                receptor.cpuAnimTimer += (note.sustainLength / 1000);
            }
            note.alpha = 0.4;
        } else
            note.alpha = 1;
    });

    strumLine.y = timeToY(Conductor.position - sectionStartTime());
    camFollow.y = strumLine.y + 50;
    strumNotes.forEach((receptor:Receptor) -> receptor.y = strumLine.y);
    FlxG.camera.snapToTarget();

    bpmTxt.text = (FlxStringUtil.formatTime(Conductor.position / 1000)
        + " / "
        + FlxStringUtil.formatTime(FlxG.sound.music.length / 1000)
        + "\nBeat: "
        + curBeat
        + "\nStep: "
        + curStep
        + "\nSection: "
        + selectedSection
    );
}